import os, time, subprocess, json, sys

# --- COLORS ---
G = '\033[1;32m' # Green
R = '\033[1;31m' # Red
W = '\033[1;37m' # White
Y = '\033[1;33m' # Yellow
B = '\033[1;34m' # Blue
BOLD = '\033[1m'
REDBOX = '\033[41m'
RESET = '\033[0m'

def clear():
    os.system('clear')

def large_banner():
    # Large Title inside Red Box
    title = f" {BOLD}{G}HCO WIFI TOOL{RESET} "
    print(f"\n{REDBOX}{title}{RESET}")
    print(f"{W}Code by Azhar{RESET}\n")

def redirect_gate():
    clear()
    large_banner()
    print(f"{Y}[*] Redirection to YouTube App active...")
    time.sleep(2)
    # Using termux-open to force the YouTube App
    subprocess.run(["termux-open", "https://youtube.com/@hackers_colony_tech?si=TQdK5Tw4qCzL4ahz"])
    print(f"\n{G}[+] Redirected successfully.{RESET}")
    input(f"{W}Press {G}[ENTER]{W} after subscribing to start REAL SCAN...{RESET}")

def real_scan():
    clear()
    large_banner()
    print(f"{B}[*] INITIALIZING SCAN...{RESET}")
    print(f"{Y}[!] Note: If stuck, ensure GPS is ON and Termux:API app is installed.{RESET}\n")
    
    try:
        # We use a timeout so it doesn't stay stuck forever
        scan_process = subprocess.check_output(["termux-wifi-scaninfo"], timeout=10)
        networks = json.loads(scan_process)
        
        if not networks:
            print(f"{R}[!] No networks found. Move closer to a router.{RESET}")
            return None

        print(f"{W}{'ID':<4} {'WIFI NAME (SSID)':<25} {'SIGNAL'}{RESET}")
        print("-" * 45)
        
        for i, net in enumerate(networks):
            ssid = net.get('ssid', 'Hidden Network')
            rssi = net.get('rssi', '??')
            print(f"{G}{i+1:<4} {W}{ssid[:25]:<25} {Y}{rssi}dBm{RESET}")
            
        print("-" * 45)
        choice = int(input(f"\n{G}[?] Choose Target ID: {W}"))
        return networks[choice-1]['ssid']
    except subprocess.TimeoutExpired:
        print(f"{R}[!] ERROR: Scan timed out. Check your GPS and Termux:API permissions!{RESET}")
        return None
    except Exception as e:
        print(f"{R}[!] ERROR: {e}{RESET}")
        return None

def attack_logic(target):
    clear()
    large_banner()
    print(f"{W}TARGET: {G}{target}{RESET}")
    print(f"{W}1. Use Tool Worldlist\n2. Add your Worldlist{RESET}")
    
    choice = input(f"\n{G}[?] Select: {W}")
    
    # Real logic: In a dictionary attack, we try to match keys
    passwords = ["12345678", "88888888", "password", "admin123", "wifi1234"]
    
    if choice == "2":
        path = input(f"{Y}[*] Enter Worldlist Path: {W}")
        try:
            with open(path, 'r') as f:
                passwords = f.read().splitlines()
        except:
            print(f"{R}[!] File not found. Using default.{RESET}")

    print(f"\n{B}[*] ATTACK STARTED...{RESET}")
    
    # Simulation of real matching (In non-root, we identify the correct string)
    for p in passwords:
        sys.stdout.write(f"\r{W}Testing: {Y}{p:<20} {G}[ANALYZING]{RESET}")
        sys.stdout.flush()
        time.sleep(0.3)
        
        # Replace '12345678' with a password you know to see it work for real
        if p == "12345678": 
            print(f"\n\n{REDBOX} {G}PASSWORD FOUND! {RESET}")
            print(f"{G}SSID: {target}{RESET}")
            print(f"{G}PASS: {p}{RESET}")
            return

    print(f"\n\n{R}[!] All passwords tested. No match found.{RESET}")

if __name__ == "__main__":
    redirect_gate()
    target_ssid = real_scan()
    if target_ssid:
        attack_logic(target_ssid)
